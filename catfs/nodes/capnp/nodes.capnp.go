// Code generated by capnpc-go. DO NOT EDIT.

package capnp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	strconv "strconv"
)

// Commit is a set of changes to nodes
type Commit capnp.Struct
type Commit_merge Commit

// Commit_TypeID is the unique identifier for the type Commit.
const Commit_TypeID = 0x8da013c66e545daf

func NewCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit(st), err
}

func NewRootCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit(st), err
}

func ReadRootCommit(msg *capnp.Message) (Commit, error) {
	root, err := msg.Root()
	return Commit(root.Struct()), err
}

func (s Commit) String() string {
	str, _ := text.Marshal(0x8da013c66e545daf, capnp.Struct(s))
	return str
}

func (s Commit) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Commit) DecodeFromPtr(p capnp.Ptr) Commit {
	return Commit(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Commit) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Commit) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Commit) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Commit) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Commit) Msg() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Commit) HasMsg() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Commit) MsgBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Commit) SetMsg(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Commit) Author() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Commit) HasAuthor() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Commit) AuthorBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Commit) SetAuthor(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Commit) Parent() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return []byte(p.Data()), err
}

func (s Commit) HasParent() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Commit) SetParent(v []byte) error {
	return capnp.Struct(s).SetData(2, v)
}

func (s Commit) Root() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Commit) HasRoot() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Commit) SetRoot(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Commit) Index() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Commit) SetIndex(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Commit) Merge() Commit_merge { return Commit_merge(s) }

func (s Commit_merge) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Commit_merge) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Commit_merge) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Commit_merge) With() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s Commit_merge) HasWith() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Commit_merge) WithBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s Commit_merge) SetWith(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s Commit_merge) Head() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return []byte(p.Data()), err
}

func (s Commit_merge) HasHead() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Commit_merge) SetHead(v []byte) error {
	return capnp.Struct(s).SetData(5, v)
}

// Commit_List is a list of Commit.
type Commit_List = capnp.StructList[Commit]

// NewCommit creates a new list of Commit.
func NewCommit_List(s *capnp.Segment, sz int32) (Commit_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6}, sz)
	return capnp.StructList[Commit](l), err
}

// Commit_Future is a wrapper for a Commit promised by a client call.
type Commit_Future struct{ *capnp.Future }

func (f Commit_Future) Struct() (Commit, error) {
	p, err := f.Future.Ptr()
	return Commit(p.Struct()), err
}
func (p Commit_Future) Merge() Commit_merge_Future { return Commit_merge_Future{p.Future} }

// Commit_merge_Future is a wrapper for a Commit_merge promised by a client call.
type Commit_merge_Future struct{ *capnp.Future }

func (f Commit_merge_Future) Struct() (Commit_merge, error) {
	p, err := f.Future.Ptr()
	return Commit_merge(p.Struct()), err
}

// A single directory entry
type DirEntry capnp.Struct

// DirEntry_TypeID is the unique identifier for the type DirEntry.
const DirEntry_TypeID = 0x8b15ee76774b1f9d

func NewDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry(st), err
}

func NewRootDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry(st), err
}

func ReadRootDirEntry(msg *capnp.Message) (DirEntry, error) {
	root, err := msg.Root()
	return DirEntry(root.Struct()), err
}

func (s DirEntry) String() string {
	str, _ := text.Marshal(0x8b15ee76774b1f9d, capnp.Struct(s))
	return str
}

func (s DirEntry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (DirEntry) DecodeFromPtr(p capnp.Ptr) DirEntry {
	return DirEntry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s DirEntry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s DirEntry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s DirEntry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s DirEntry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s DirEntry) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s DirEntry) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s DirEntry) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s DirEntry) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s DirEntry) Hash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s DirEntry) HasHash() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s DirEntry) SetHash(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// DirEntry_List is a list of DirEntry.
type DirEntry_List = capnp.StructList[DirEntry]

// NewDirEntry creates a new list of DirEntry.
func NewDirEntry_List(s *capnp.Segment, sz int32) (DirEntry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[DirEntry](l), err
}

// DirEntry_Future is a wrapper for a DirEntry promised by a client call.
type DirEntry_Future struct{ *capnp.Future }

func (f DirEntry_Future) Struct() (DirEntry, error) {
	p, err := f.Future.Ptr()
	return DirEntry(p.Struct()), err
}

// Directory contains one or more directories or files
type Directory capnp.Struct

// Directory_TypeID is the unique identifier for the type Directory.
const Directory_TypeID = 0xe24c59306c829c01

func NewDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return Directory(st), err
}

func NewRootDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return Directory(st), err
}

func ReadRootDirectory(msg *capnp.Message) (Directory, error) {
	root, err := msg.Root()
	return Directory(root.Struct()), err
}

func (s Directory) String() string {
	str, _ := text.Marshal(0xe24c59306c829c01, capnp.Struct(s))
	return str
}

func (s Directory) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Directory) DecodeFromPtr(p capnp.Ptr) Directory {
	return Directory(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Directory) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Directory) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Directory) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Directory) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Directory) Size() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Directory) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Directory) Parent() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Directory) HasParent() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Directory) ParentBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Directory) SetParent(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Directory) Children() (DirEntry_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return DirEntry_List(p.List()), err
}

func (s Directory) HasChildren() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Directory) SetChildren(v DirEntry_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewChildren sets the children field to a newly
// allocated DirEntry_List, preferring placement in s's segment.
func (s Directory) NewChildren(n int32) (DirEntry_List, error) {
	l, err := NewDirEntry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return DirEntry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Directory) Contents() (DirEntry_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return DirEntry_List(p.List()), err
}

func (s Directory) HasContents() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Directory) SetContents(v DirEntry_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewContents sets the contents field to a newly
// allocated DirEntry_List, preferring placement in s's segment.
func (s Directory) NewContents(n int32) (DirEntry_List, error) {
	l, err := NewDirEntry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return DirEntry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// Directory_List is a list of Directory.
type Directory_List = capnp.StructList[Directory]

// NewDirectory creates a new list of Directory.
func NewDirectory_List(s *capnp.Segment, sz int32) (Directory_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3}, sz)
	return capnp.StructList[Directory](l), err
}

// Directory_Future is a wrapper for a Directory promised by a client call.
type Directory_Future struct{ *capnp.Future }

func (f Directory_Future) Struct() (Directory, error) {
	p, err := f.Future.Ptr()
	return Directory(p.Struct()), err
}

// A leaf node in the MDAG
type File capnp.Struct

// File_TypeID is the unique identifier for the type File.
const File_TypeID = 0x8ea7393d37893155

func NewFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return File(st), err
}

func NewRootFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return File(st), err
}

func ReadRootFile(msg *capnp.Message) (File, error) {
	root, err := msg.Root()
	return File(root.Struct()), err
}

func (s File) String() string {
	str, _ := text.Marshal(0x8ea7393d37893155, capnp.Struct(s))
	return str
}

func (s File) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (File) DecodeFromPtr(p capnp.Ptr) File {
	return File(capnp.Struct{}.DecodeFromPtr(p))
}

func (s File) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s File) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s File) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s File) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s File) Size() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s File) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s File) Parent() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s File) HasParent() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s File) ParentBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s File) SetParent(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s File) Key() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s File) HasKey() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s File) SetKey(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// File_List is a list of File.
type File_List = capnp.StructList[File]

// NewFile creates a new list of File.
func NewFile_List(s *capnp.Segment, sz int32) (File_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[File](l), err
}

// File_Future is a wrapper for a File promised by a client call.
type File_Future struct{ *capnp.Future }

func (f File_Future) Struct() (File, error) {
	p, err := f.Future.Ptr()
	return File(p.Struct()), err
}

// Ghost indicates that a certain node was at this path once
type Ghost capnp.Struct
type Ghost_Which uint16

const (
	Ghost_Which_commit    Ghost_Which = 0
	Ghost_Which_directory Ghost_Which = 1
	Ghost_Which_file      Ghost_Which = 2
)

func (w Ghost_Which) String() string {
	const s = "commitdirectoryfile"
	switch w {
	case Ghost_Which_commit:
		return s[0:6]
	case Ghost_Which_directory:
		return s[6:15]
	case Ghost_Which_file:
		return s[15:19]

	}
	return "Ghost_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Ghost_TypeID is the unique identifier for the type Ghost.
const Ghost_TypeID = 0x80c828d7e89c12ea

func NewGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Ghost(st), err
}

func NewRootGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Ghost(st), err
}

func ReadRootGhost(msg *capnp.Message) (Ghost, error) {
	root, err := msg.Root()
	return Ghost(root.Struct()), err
}

func (s Ghost) String() string {
	str, _ := text.Marshal(0x80c828d7e89c12ea, capnp.Struct(s))
	return str
}

func (s Ghost) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Ghost) DecodeFromPtr(p capnp.Ptr) Ghost {
	return Ghost(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Ghost) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Ghost) Which() Ghost_Which {
	return Ghost_Which(capnp.Struct(s).Uint16(8))
}
func (s Ghost) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Ghost) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Ghost) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Ghost) GhostInode() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Ghost) SetGhostInode(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Ghost) GhostPath() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Ghost) HasGhostPath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Ghost) GhostPathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Ghost) SetGhostPath(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Ghost) Commit() (Commit, error) {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != commit")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return Commit(p.Struct()), err
}

func (s Ghost) HasCommit() bool {
	if capnp.Struct(s).Uint16(8) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Ghost) SetCommit(v Commit) error {
	capnp.Struct(s).SetUint16(8, 0)
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewCommit sets the commit field to a newly
// allocated Commit struct, preferring placement in s's segment.
func (s Ghost) NewCommit() (Commit, error) {
	capnp.Struct(s).SetUint16(8, 0)
	ss, err := NewCommit(capnp.Struct(s).Segment())
	if err != nil {
		return Commit{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Ghost) Directory() (Directory, error) {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != directory")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return Directory(p.Struct()), err
}

func (s Ghost) HasDirectory() bool {
	if capnp.Struct(s).Uint16(8) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Ghost) SetDirectory(v Directory) error {
	capnp.Struct(s).SetUint16(8, 1)
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Directory struct, preferring placement in s's segment.
func (s Ghost) NewDirectory() (Directory, error) {
	capnp.Struct(s).SetUint16(8, 1)
	ss, err := NewDirectory(capnp.Struct(s).Segment())
	if err != nil {
		return Directory{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Ghost) File() (File, error) {
	if capnp.Struct(s).Uint16(8) != 2 {
		panic("Which() != file")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return File(p.Struct()), err
}

func (s Ghost) HasFile() bool {
	if capnp.Struct(s).Uint16(8) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Ghost) SetFile(v File) error {
	capnp.Struct(s).SetUint16(8, 2)
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewFile sets the file field to a newly
// allocated File struct, preferring placement in s's segment.
func (s Ghost) NewFile() (File, error) {
	capnp.Struct(s).SetUint16(8, 2)
	ss, err := NewFile(capnp.Struct(s).Segment())
	if err != nil {
		return File{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Ghost_List is a list of Ghost.
type Ghost_List = capnp.StructList[Ghost]

// NewGhost creates a new list of Ghost.
func NewGhost_List(s *capnp.Segment, sz int32) (Ghost_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Ghost](l), err
}

// Ghost_Future is a wrapper for a Ghost promised by a client call.
type Ghost_Future struct{ *capnp.Future }

func (f Ghost_Future) Struct() (Ghost, error) {
	p, err := f.Future.Ptr()
	return Ghost(p.Struct()), err
}
func (p Ghost_Future) Commit() Commit_Future {
	return Commit_Future{Future: p.Future.Field(1, nil)}
}
func (p Ghost_Future) Directory() Directory_Future {
	return Directory_Future{Future: p.Future.Field(1, nil)}
}
func (p Ghost_Future) File() File_Future {
	return File_Future{Future: p.Future.Field(1, nil)}
}

// Node is a node in the merkle dag of floo
type Node capnp.Struct
type Node_Which uint16

const (
	Node_Which_commit    Node_Which = 0
	Node_Which_directory Node_Which = 1
	Node_Which_file      Node_Which = 2
	Node_Which_ghost     Node_Which = 3
)

func (w Node_Which) String() string {
	const s = "commitdirectoryfileghost"
	switch w {
	case Node_Which_commit:
		return s[0:6]
	case Node_Which_directory:
		return s[6:15]
	case Node_Which_file:
		return s[15:19]
	case Node_Which_ghost:
		return s[19:24]

	}
	return "Node_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Node_TypeID is the unique identifier for the type Node.
const Node_TypeID = 0xa629eb7f7066fae3

func NewNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return Node(st), err
}

func NewRootNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return Node(st), err
}

func ReadRootNode(msg *capnp.Message) (Node, error) {
	root, err := msg.Root()
	return Node(root.Struct()), err
}

func (s Node) String() string {
	str, _ := text.Marshal(0xa629eb7f7066fae3, capnp.Struct(s))
	return str
}

func (s Node) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node) DecodeFromPtr(p capnp.Ptr) Node {
	return Node(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Node) Which() Node_Which {
	return Node_Which(capnp.Struct(s).Uint16(8))
}
func (s Node) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Node) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Node) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Node) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Node) TreeHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Node) HasTreeHash() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Node) SetTreeHash(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Node) ModTime() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s Node) HasModTime() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Node) ModTimeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s Node) SetModTime(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s Node) Inode() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Node) SetInode(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Node) ContentHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Node) HasContentHash() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Node) SetContentHash(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Node) User() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s Node) HasUser() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Node) UserBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s Node) SetUser(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s Node) Commit() (Commit, error) {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != commit")
	}
	p, err := capnp.Struct(s).Ptr(5)
	return Commit(p.Struct()), err
}

func (s Node) HasCommit() bool {
	if capnp.Struct(s).Uint16(8) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(5)
}

func (s Node) SetCommit(v Commit) error {
	capnp.Struct(s).SetUint16(8, 0)
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewCommit sets the commit field to a newly
// allocated Commit struct, preferring placement in s's segment.
func (s Node) NewCommit() (Commit, error) {
	capnp.Struct(s).SetUint16(8, 0)
	ss, err := NewCommit(capnp.Struct(s).Segment())
	if err != nil {
		return Commit{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Node) Directory() (Directory, error) {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != directory")
	}
	p, err := capnp.Struct(s).Ptr(5)
	return Directory(p.Struct()), err
}

func (s Node) HasDirectory() bool {
	if capnp.Struct(s).Uint16(8) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(5)
}

func (s Node) SetDirectory(v Directory) error {
	capnp.Struct(s).SetUint16(8, 1)
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Directory struct, preferring placement in s's segment.
func (s Node) NewDirectory() (Directory, error) {
	capnp.Struct(s).SetUint16(8, 1)
	ss, err := NewDirectory(capnp.Struct(s).Segment())
	if err != nil {
		return Directory{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Node) File() (File, error) {
	if capnp.Struct(s).Uint16(8) != 2 {
		panic("Which() != file")
	}
	p, err := capnp.Struct(s).Ptr(5)
	return File(p.Struct()), err
}

func (s Node) HasFile() bool {
	if capnp.Struct(s).Uint16(8) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(5)
}

func (s Node) SetFile(v File) error {
	capnp.Struct(s).SetUint16(8, 2)
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewFile sets the file field to a newly
// allocated File struct, preferring placement in s's segment.
func (s Node) NewFile() (File, error) {
	capnp.Struct(s).SetUint16(8, 2)
	ss, err := NewFile(capnp.Struct(s).Segment())
	if err != nil {
		return File{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Node) Ghost() (Ghost, error) {
	if capnp.Struct(s).Uint16(8) != 3 {
		panic("Which() != ghost")
	}
	p, err := capnp.Struct(s).Ptr(5)
	return Ghost(p.Struct()), err
}

func (s Node) HasGhost() bool {
	if capnp.Struct(s).Uint16(8) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(5)
}

func (s Node) SetGhost(v Ghost) error {
	capnp.Struct(s).SetUint16(8, 3)
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewGhost sets the ghost field to a newly
// allocated Ghost struct, preferring placement in s's segment.
func (s Node) NewGhost() (Ghost, error) {
	capnp.Struct(s).SetUint16(8, 3)
	ss, err := NewGhost(capnp.Struct(s).Segment())
	if err != nil {
		return Ghost{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Node) BackendHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return []byte(p.Data()), err
}

func (s Node) HasBackendHash() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Node) SetBackendHash(v []byte) error {
	return capnp.Struct(s).SetData(6, v)
}

// Node_List is a list of Node.
type Node_List = capnp.StructList[Node]

// NewNode creates a new list of Node.
func NewNode_List(s *capnp.Segment, sz int32) (Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7}, sz)
	return capnp.StructList[Node](l), err
}

// Node_Future is a wrapper for a Node promised by a client call.
type Node_Future struct{ *capnp.Future }

func (f Node_Future) Struct() (Node, error) {
	p, err := f.Future.Ptr()
	return Node(p.Struct()), err
}
func (p Node_Future) Commit() Commit_Future {
	return Commit_Future{Future: p.Future.Field(5, nil)}
}
func (p Node_Future) Directory() Directory_Future {
	return Directory_Future{Future: p.Future.Field(5, nil)}
}
func (p Node_Future) File() File_Future {
	return File_Future{Future: p.Future.Field(5, nil)}
}
func (p Node_Future) Ghost() Ghost_Future {
	return Ghost_Future{Future: p.Future.Field(5, nil)}
}

const schema_9195d073cb5c5953 = "x\xda\xb4V\xdfo\x14\xd5\x17?\x9f{gwX\xd2" +
	"~w\xf7;m\xc2\x83\xcd\xde\x00\xc6B*\xb4\x14#" +
	"\x10\x8c\x14[ik!\xbdl\x1b\xc1\xa0q\xd8\xbd\xed" +
	"\x8c\xec\xce43\x83u\x8d\x06$\x90\x80\xa6\x06\"&" +
	"\x92\x94\x88\xa6\xf8#\x91\xe0?`LL0F_\x8c" +
	"\x0f\x9a\xf8\xa8&\x1aM|V#\x8c\xb9\xb3\xbfJ\x03" +
	"\x08\x0f\xbe\xed|\xce\x99{\xcf\xf9\x9c\xcf\xf9\xcc\xf6g" +
	"\xf8.c\xa0\xf3\x01\x83\x98\xecO\xa5\xe3_\xff\xbf\xf8" +
	"\xcbw\xbd_\x1c'\xb9\x0e,.\x1e<\xf4U\xf8\xf5" +
	"\x9b\xe7h\x84\x99\x1c\xc6\xe0\x9f\x18\x87\xd5\xc9L\xab\x93" +
	"\x15\x06\xc7X\x01\x84\xf8b\xe1\x89\xf9\xe7\x7f\xef~\x8d" +
	"\xf2\xeb\xd0~!\xc5L\xa2A\xc5\x0f\xc3\xaaq\xd3\xaa" +
	"\xf1\x82u\x99\xcf\x13\xe2\xabOOy\x9f[\x97\x16\xf4" +
	"\x05\xcb\xf3\xd3:\x1f\xc6~X\xdd\x86iu\x1b\x85\xc1" +
	"\x11\xe3I}\xfe\xf4\xc0\x99\x87\x1f\xd9\xfe\xfe\xeb+_" +
	"H.8\x9a\xda\x0d\xebT\xca\xb4N\xa5\x0a\xd6\x95\xd4" +
	"UB\xfc\xe3_3s\xc7~\xdb\xf0\xde\xca\x0eL\xd3" +
	"\x8018\x92\xde\x0dk:mZ\xd3\xe9\xc2\xe0\x99\xb4" +
	"\xcf\x08\xf1\xd2O\x13\xdfg\x97\xfe\xf8\x94\xe4F,+" +
	"\xb0;m\x82h0\x9f9\x01\x82\xd5\x93\xd1\xd5c\xf1" +
	"D\xa5\xff\xe0\xc4\x0f+\x8b\xe1\xba\x98Z\xe69X\x0b" +
	"\x19\xd3Z\xc8\x14\xack\x99\x9fi[<S\xf1\xfd\xcd" +
	"%;2f\xc2\xcd\x9e_V\xe1\xe6\x92=\xe7\xcd\xd5" +
	"\x7foJ~\xef\xd8\xe3\xf8aD4\x09H\x03,~" +
	"\xe6\x8d\xb7\xe5'\xdf\xbez\x8d\xa4\xc10\xd4\x07t\x10" +
	"\x0d\xe0\x1b\xc4I\x9ep\xbdt\xd9-\xd9\x91\x0aE\xe4" +
	"\xd8\x91\xb0EI\x05\x91\xedzB\x9f)\xe6\xedP\xd8" +
	"\x91\x88\x1c7\x14sv\xe4\x08\xdf+A\x11\xc9.n" +
	"\x10\x19 \xca\xbf\xfc\x14\x91|\x89C\x9ef\x00\xba\xa0" +
	"\xb1S\xfb\x89\xe4I\x0ey\x96\xa1\x87\xc51\xba\xc0\x88" +
	"\xf2\x0b;\x88\xe4i\x0ey\x9e\xa1\x87\xdf\xd00'\xca" +
	"\x9f\xd3\xd9g9\xe4\"C\x8fq]\xc3\x06Q\xfe\xc2" +
	"F\"y\x9eC^b\x88gu\xb5c\x9eO\xbc\xac" +
	"\x90!\x86\x0c5\xc0I;\"8\xe8 \x86\x0e\xc2\xa3" +
	"%\xbfZu#\xe4\xda\xc4\x13\x90#\xc4e7P\xa5" +
	"\xc8\x0f\x085\xe4\xda\xcc\xd7\xa3\xd9\x19\xb7\xa2\x90k\xab" +
	"\xa3\xf1\xd2\xdd\x10>\xec\x06#\x9e\x19\x05\xb5[S~" +
	"_By\x1e_\xc6C\"t\xbd\xd9\x8ab\xa2YK" +
	"M(/\x0aj\x04\xb9\xaa\xc5\xe7\x06\xdd\xf6z\x0e\xd9" +
	"\xcf\x90o\x12\xfa\xa0\x06{9\xe4V\x86\xacgWU" +
	"\xb3\xdf\xacc\x87\x0e:\x89\xa1\xf3.\xcb}L\x13\x84" +
	"\xe8\xd6\xc5\x8a\x86>\xd6\"N\xf2\"\xe1\xf2P\xd8\"" +
	"T\x91\xf0gD\xc9\xb1\xbdY-\x15_x\xbeYV" +
	"!\x91\\\xd3\xaa\xfc\xc2\xda\xf6\xc0Z\x95_\xd43\x7f" +
	"\x8bC.1\xe4\x19\xab\x0b\xe1\x1d\x0d.r\xc8\x0f\x18" +
	"\xf2\x9c\xd7epY\xf7x\x89C~\xc4\x00\xa3\xae\x81" +
	"\x0f\xb7\x10\xc9%\x0e\xf91\x03RX\xb6\\\xf9+[" +
	"\x88\x99\xd5p\xb65y\xfbh\xe4\xf8A\xebq\xce\x0e" +
	"\x94\x175\xa9\xc9\x06\xbe\xdfz(\xb8^Y\xbd\x80\x14" +
	"1\xa4\x08\x85\xaa\x0af\xd5]q\xf7\xb8[Q\xb7\xd9" +
	"\xac5\x8d1\x7f\x16\x0f\x89\x8a\xb2g\x84\xc7\xf4\x02\xb9" +
	"\x9e\x88\x1c%\xf6\x0e\x0f\xed!\"\xd9\xd1\"kDw" +
	"\xbb\x8bCN\xb4\xd7fL\xd32\xcc!'5W\x8d" +
	"\xa5\xd9\xabY\x1d\xe5\x90S\x0c\xd9\xd0}\xb1%\xfff" +
	"\x87\x8d\x86\xcd#\xaavOB\xd8\xe7\x97o\xd7\xcc\xfa" +
	"\x86\x0c\xc6\x11\xefK\xba\x08\x85a\xd7\x1d\xa1\xd1PU" +
	"\x05G*J\x94\xedY\xad\x0b}\x1dA\xf65\xbb\xb3" +
	"\xee\xc7F\xa2\xa2\x00G\xb1\x0fm5X\x1b0NT" +
	"\xec\xd5\xf8V\xb4\x05a\x0d`7Q\xb1O\xe3\xdb\xc0" +
	"\x80\xba$\xac\x87\xb0\x85\xa8\xd8\xaf\xe1\x9d:\xdd\xe0\x89" +
	",\xac\xed8LT\xdc\xa6\xf1a\x8d\xa7\x8c.\xa4\x88" +
	"\xac\xa1\xe4\xda\x9d\x1a\x1f\x05CO:\x8eS]H\x13" +
	"Y#\xd8AT\xdc\xa5#\x13:b\xde\xd0\x11\x93\xc8" +
	"\x1a\xc3~\xa2\xe2\xa8\x8eL\xe9\xc8\xaa\xeb:\xb2\x8a\xc8" +
	"\x92\xc9i\x13:r@G2\x7f\xebH\x86\xc8\x9aN" +
	"\xea\x9a\xd4\x91C\xfa\xfe\xd5\xe9.\xac&\xb2\x0e&u" +
	"\x1d\xd0x\x19+65\x8e\x02\xa5F\xed\xd0!\xa2\xe6" +
	"\x9c\x8eU\xfd\xf2\x94\xdb\xce)\xb8\x9a\xe3\x96\xbf\x95|" +
	"/R^4J\xe6\xb2%\xcf\x1e\x0dU\xf0\xdf\xd8]" +
	"!1T\xe4\xda\x9f\xed\xc6a\x87\xed\xd2\x11\xe5\x95o" +
	".\xa4%\xb2\xd4\xbf\xb9M\xb4)Y1\xd2.\x97\xab" +
	"\x8fj\x85\xcd\xd5\xa7t\xb3\xcd\xcd\xbb\x91\xd3\xb69e" +
	"\x97\xefI\xdd\xc3\xba\xff\xac\xf6\xd8[K\xbc\xb7!\xf1" +
	"w\x11\x0f7\xa8J\xd5\x84f\xdcv\xbdP\xf8\x9e\x12" +
	"~ \xaa~\xa0Zn\xed\xaaPc3\xaeYI\x9c" +
	"/\xd7Zf[\xd7}\x88C:\xedeVz\x99\x9f" +
	"\xe5\x90\x95e\xcb\xec\x8e\x13I\x87C\x9e\xd4\xc6\xc7\xea" +
	"\xc6\xf7\x8a\x06\x8f\xd7\xbf\x7fw\xda\xf0\xb8\xe4\xb8\x95r" +
	"\xa0<\xad\xa0\xff\x11&9\x90k\xffa\"h\xb0)" +
	"\x9a\xf0NI\xff\x04\x00\x00\xff\xff\xe1\x12L("

func init() {
	schemas.Register(schema_9195d073cb5c5953,
		0x80c828d7e89c12ea,
		0x8b15ee76774b1f9d,
		0x8da013c66e545daf,
		0x8ea7393d37893155,
		0xa629eb7f7066fae3,
		0xbff8a40fda4ce4a4,
		0xe24c59306c829c01)
}
